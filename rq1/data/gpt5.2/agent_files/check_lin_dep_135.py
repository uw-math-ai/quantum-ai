import stim
import numpy as np

def check_linear_dependence():
    with open('data/gemini-3-pro-preview/agent_files/stabilizers_135.txt', 'r') as f:
        stabs = [line.strip() for line in f if line.strip()]

    # Remove 119
    stabs_subset = [s for i, s in enumerate(stabs) if i != 119]
    indices_subset = [i for i, s in enumerate(stabs) if i != 119]
    
    # We want to check if 44 is in the span of the others (excluding 44 and 119)
    # 44 is in stabs_subset.
    
    # Create tableau from ALL except 44 (and 119)
    stabs_others = [s for i, s in enumerate(stabs) if i != 119 and i != 44]
    
    try:
        t = stim.Tableau.from_stabilizers([stim.PauliString(s) for s in stabs_others], allow_underconstrained=True, allow_redundant=True)
        # If 44 is independent, then adding it should not conflict with the state prepared by others.
        # But wait, 44 might be dependent.
        
        # Let's see if 44 is satisfied by the tableau generated by others.
        # We can measure 44 on the tableau.
        
        # Or better: check if (others + 44) has same rank as (others).
        
        # Using stim to check satisfaction.
        p44 = stim.PauliString(stabs[44])
        
        # Apply the tableau operations to |0> state is implicit.
        # We can iterate through the stabilizers of the tableau (z_output) and see if p44 is generated.
        
        # Actually, let's just ask stim to generate a tableau for {others}.
        # Then check if p44 has expectation value +1, -1 or 0.
        
        # If expectation is +1, then 44 is dependent and consistent.
        # If -1, then 44 is dependent and inconsistent (impossible if we started with +1 generators and they commute).
        # If 0, then 44 is independent.
        
        sim = stim.TableauSimulator()
        sim.set_inverse_tableau(t) # Set state to stabilizers
        # Wait, set_inverse_tableau sets the state to be the one stabilized by Z_i mapping to stabilizers.
        # No, tableau maps Z basis to stabilizers.
        # So we want the tableau 't'.
        
        # Actually, simpler:
        # Generate circuit for 'others'.
        # Simulate it and measure 44.
        
        circ = t.to_circuit("elimination")
        sim = stim.TableauSimulator()
        sim.do(circ)
        
        obs = sim.peek_observable_expectation(p44)
        print(f"Expectation of Stab 44 given others: {obs}")
        
    except Exception as e:
        print(f"Error: {e}")

    # Similarly for 59
    stabs_others_59 = [s for i, s in enumerate(stabs) if i != 119 and i != 59]
    try:
        t = stim.Tableau.from_stabilizers([stim.PauliString(s) for s in stabs_others_59], allow_underconstrained=True, allow_redundant=True)
        circ = t.to_circuit("elimination")
        sim = stim.TableauSimulator()
        sim.do(circ)
        p59 = stim.PauliString(stabs[59])
        obs = sim.peek_observable_expectation(p59)
        print(f"Expectation of Stab 59 given others: {obs}")
    except Exception as e:
        print(f"Error 59: {e}")

if __name__ == "__main__":
    check_linear_dependence()
