import stim
import numpy as np

stabilizers = [
    "XZZXIIIIIIIIIIIIIIII", "IIIIIXZZXIIIIIIIIIII", "IIIIIIIIIIXZZXIIIIII", "IIIIIIIIIIIIIIIXZZXI",
    "IXZZXIIIIIIIIIIIIIII", "IIIIIIXZZXIIIIIIIIII", "IIIIIIIIIIIXZZXIIIII", "IIIIIIIIIIIIIIIIXZZX",
    "XIXZZIIIIIIIIIIIIIII", "IIIIIXIXZZIIIIIIIIII", "IIIIIIIIIIXIXZZIIIII", "IIIIIIIIIIIIIIIXIXZZ",
    "ZXIXZIIIIIIIIIIIIIII", "IIIIIZXIXZIIIIIIIIII", "IIIIIIIIIIZXIXZIIIII", "IIIIIIIIIIIIIIIZXIXZ",
    "XXXXXXXXXXXXXXXXXXXX", "ZZZZZZZZZZZZZZZZZZZZ"
]

def solve():
    num_qubits = 20
    print(f"Num stabilizers: {len(stabilizers)}")
    
    # Convert to binary matrix
    # Columns: X0..X19, Z0..Z19
    mat = []
    for s in stabilizers:
        row = []
        ps = stim.PauliString(s)
        for k in range(num_qubits):
            # X component (1 if X or Y)
            if ps[k] in [1, 2]: row.append(1)
            else: row.append(0)
        for k in range(num_qubits):
            # Z component (1 if Z or Y)
            if ps[k] in [3, 2]: row.append(1)
            else: row.append(0)
        mat.append(row)
    
    import galois
    gf = galois.GF(2)
    m = gf(mat)
    
    # Null space
    # The null space of the parity check matrix corresponds to operators that commute with all stabilizers?
    # No. Commutativity is defined by the symplectic product.
    # A Pauli P = (x, z) commutes with S = (sx, sz) iff x*sz + z*sx = 0 (mod 2).
    # So we want to find vectors v such that v * Omega * S^T = 0 for all S in stabilizers.
    # where Omega = [[0, I], [I, 0]].
    
    # Let H be the matrix of stabilizers (18 x 40).
    # We want x such that H * Omega * x^T = 0.
    # So we need the null space of H * Omega.
    
    # Construct Omega
    omega = np.zeros((2*num_qubits, 2*num_qubits), dtype=int)
    for i in range(num_qubits):
        omega[i, i+num_qubits] = 1
        omega[i+num_qubits, i] = 1
        
    omega_gf = gf(omega)
    
    # Compute symplectic form matrix
    h_omega = m @ omega_gf
    
    # Find null space
    null_space = h_omega.null_space()
    print(f"Null space dimension: {null_space.shape[0]}")
    
    # The null space contains the normalizer group.
    # It should have dimension 20 + (20-18) = 22.
    # The stabilizers themselves are in the null space because they commute with each other.
    
    # We need to pick 2 operators from the null space that are NOT generated by the stabilizers.
    # And we want them to commute with each other (to form a valid set of compatible observables).
    
    # Let's convert null space basis back to Pauli strings
    normalizers = []
    for row in null_space:
        # row is [x0..x19, z0..z19]
        ps_str = []
        for k in range(num_qubits):
            x = row[k]
            z = row[k+num_qubits]
            if x == 0 and z == 0: ps_str.append("I")
            elif x == 1 and z == 0: ps_str.append("X")
            elif x == 0 and z == 1: ps_str.append("Z")
            elif x == 1 and z == 1: ps_str.append("Y")
        normalizers.append(stim.PauliString("".join(ps_str)))
        
    print(f"Found {len(normalizers)} generators for the normalizer.")
    
    # Now we filter out the ones that are dependent on the stabilizers.
    # We can just try to add them to the tableau and see if rank increases.
    
    candidates = []
    current_stabs = [stim.PauliString(s) for s in stabilizers]
    
    for norm in normalizers:
        # Check if independent
        try:
            # Check independence by rank
            test_stabs = current_stabs + candidates + [norm]
            # Convert to matrix to check rank
            mat_test = []
            for s in test_stabs:
                row = []
                for k in range(num_qubits):
                    if s[k] in [1, 2]: row.append(1)
                    else: row.append(0)
                for k in range(num_qubits):
                    if s[k] in [3, 2]: row.append(1)
                    else: row.append(0)
                mat_test.append(row)
            
            rank = np.linalg.matrix_rank(gf(mat_test))
            if rank == len(test_stabs):
                # Independent!
                # But we also need to check if it commutes with previously chosen candidates
                commutes = True
                for c in candidates:
                    if not norm.commutes(c):
                        commutes = False
                        break
                if commutes:
                    candidates.append(norm)
                    print(f"Added completing stabilizer: {norm}")
        except:
            pass
            
        if len(current_stabs) + len(candidates) == num_qubits:
            break
            
    if len(current_stabs) + len(candidates) == num_qubits:
        final_stabs = current_stabs + candidates
        print("Found full set of stabilizers.")
        t = stim.Tableau.from_stabilizers(final_stabs)
        c = t.to_circuit("elimination")
        with open("circuit_attempt.stim", "w") as f:
            f.write(str(c))
    else:
        print(f"Failed. Only have {len(current_stabs) + len(candidates)}")


if __name__ == "__main__":
    solve()
