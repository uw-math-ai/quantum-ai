import stim
import numpy as np

stabilizers = [
    "XXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIXXI",
    "XIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIXIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXIXIXIX",
    "IIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXXIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXX",
    "ZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIZZI",
    "ZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZIZIZIZ",
    "IIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZZZ",
    "XXXIIIIXXXIIIIXXXIIIIIIIIIIIIIIIIIIIIIIIIIXXXIIIIXXXIIIIXXXIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIXXXIIIIXXXIIIIXXXIIIIIIIIIIIIIIIIIIIIIIIIIXXXIIIIXXXIIIIXXXIIIIIIIIIII",
    "XXXIIIIIIIIIIIIIIIIIIIIIIIIIXXXIIIIXXXIIIIXXXIIIIIIIIIIIIIIIIIIIIIIIIIXXXIIIIXXXIIII",
    "XXXIIIIXXXIIIIXXXIIIIXXXIIIIXXXIIIIXXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII",
    "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXXIIIIXXXIIIIXXXIIIIXXXIIIIXXXIIIIXXXIIII",
    "IIIIIIIIIIIIIIZZZIIIIZZZIIIIZZZIIIIZZZIIIIIIIIIIIZZZIIIIIIIIIIIZZZIIIIIIIIIIIIIIIIII",
    "ZZZIIIIIIIIIIIIIIIIIIIIIIIIIZZZIIIIIIIIIIIZZZIIIIZZZIIIIZZZIIIIIIIIIIIIIIIIIIZZZIIII",
    "ZZZIIIIZZZIIIIZZZIIIIIIIIIIIIIIIIIIZZZIIIIZZZIIIIIIIIIIIIIIIIIIIIIIIIIZZZIIIIIIIIIII",
    "ZZZIIIIIIIIIIIIIIIIIIZZZIIIIZZZIIIIZZZIIIIIIIIIIIIIIIIIIZZZIIIIIIIIIIIZZZIIIIIIIIIII",
    "IIIIIIIZZZIIIIZZZIIIIIIIIIIIIIIIIIIIIIIIIIZZZIIIIZZZIIIIIIIIIIIZZZIIIIIIIIIIIZZZIIII"
]

def str_to_pauli(s):
    xs = np.array([1 if c in 'XY' else 0 for c in s], dtype=np.uint8)
    zs = np.array([1 if c in 'ZY' else 0 for c in s], dtype=np.uint8)
    return xs, zs

# Check independence
num_qubits = len(stabilizers[0])
print(f"Num qubits: {num_qubits}")
print(f"Num stabilizers: {len(stabilizers)}")

matrix = []
for s in stabilizers:
    xs, zs = str_to_pauli(s)
    row = np.concatenate([xs, zs])
    matrix.append(row)

matrix = np.array(matrix)

# Check commutation
def check_commute(mat):
    n = mat.shape[0]
    n_q = mat.shape[1] // 2
    xs = mat[:, :n_q]
    zs = mat[:, n_q:]
    comm = (xs @ zs.T + zs @ xs.T) % 2
    if np.any(comm):
        print("Stabilizers do NOT commute!")
        return False
    return True

if check_commute(matrix):
    print("Stabilizers commute.")

# Calculate rank using Gaussian elimination
def gf2_rank_and_basis(rows):
    rows = np.copy(rows)
    n_rows, n_cols = rows.shape
    pivot_row = 0
    pivots = []
    for col in range(n_cols):
        if pivot_row >= n_rows:
            break
        # Find a row with a 1 in this column
        candidates = np.where(rows[pivot_row:, col] == 1)[0]
        if len(candidates) > 0:
            swap_idx = candidates[0] + pivot_row
            rows[[pivot_row, swap_idx]] = rows[[swap_idx, pivot_row]]
            # Eliminate other rows
            for i in range(n_rows):
                if i != pivot_row and rows[i, col] == 1:
                    rows[i] ^= rows[pivot_row]
            pivots.append(pivot_row)
            pivot_row += 1
    return pivot_row, rows

rank, reduced_matrix = gf2_rank_and_basis(matrix)
print(f"Rank: {rank}")

# If incomplete, find additional stabilizers
if rank < num_qubits:
    import random
    print("Completing stabilizers...")
    
    # We need to find (num_qubits - rank) more stabilizers.
    # They must commute with all existing stabilizers and with each other.
    # And be independent.
    
    # Helper to check commutation with a single string against all rows
    def commutes_with_all(vec, mat):
        n = mat.shape[1] // 2
        xs = vec[:n]
        zs = vec[n:]
        mat_xs = mat[:, :n]
        mat_zs = mat[:, n:]
        # Commutation: x1*z2 + z1*x2 = 0
        comm = (xs @ mat_zs.T + zs @ mat_xs.T) % 2
        return np.all(comm == 0)

    completed_matrix = np.copy(matrix)
    
    # Try random Pauli strings
    # A better way is to look at the null space of the matrix in symplectic product?
    # But random search is easy for just 2 missing.
    
    added_count = 0
    while rank + added_count < num_qubits:
        # Generate random Pauli
        # Heuristic: try single Zs or Xs first, then weight-2, etc.
        # Let's just try random
        candidate = np.random.randint(0, 2, 2 * num_qubits, dtype=np.uint8)
        
        # Check commutation with all existing
        if not commutes_with_all(candidate, completed_matrix):
            continue
            
        # Check independence
        temp_matrix = np.vstack([completed_matrix, candidate])
        new_rank, _ = gf2_rank_and_basis(temp_matrix)
        
        if new_rank > rank + added_count:
            # Found one!
            print(f"Found new stabilizer {rank + added_count + 1}/{num_qubits}")
            completed_matrix = temp_matrix
            added_count += 1
            
    print("Stabilizers completed.")
    
    # Now we have a full set of stabilizers in completed_matrix
    # We can use stim.Tableau.from_stabilizers.
    # We need to convert the matrix back to list of stim.PauliString
    
    final_stabilizers = []
    for row in completed_matrix:
        s = ""
        for i in range(num_qubits):
            x = row[i]
            z = row[i + num_qubits]
            if x and z: s += "Y"
            elif x: s += "X"
            elif z: s += "Z"
            else: s += "_"
        final_stabilizers.append(stim.PauliString(s))
        
    # Use Stim to solve for the circuit
    # stim.Tableau.from_stabilizers(stabilizers, allow_redundant=False, allow_underconstrained=False)
    # But wait, from_stabilizers requires Destabilizers too? No.
    # actually stim.Tableau.from_stabilizers([s1, s2...]) creates a tableau where Z outputs are s1, s2...
    # It automatically fills in the X outputs (destabilizers) to be compatible.
    
    tableau = stim.Tableau.from_stabilizers(final_stabilizers)
    circuit = tableau.to_circuit("MPP")
    
    # But to_circuit("MPP") gives a circuit that measures the stabilizers? Or prepares them?
    # "MPP" is Measure Pauli Product.
    # Usually we want a unitary circuit.
    # tableau.to_circuit() returns a unitary circuit that implements the tableau operation.
    # The operation U such that U |0> = |stabilizer_state> is what we want?
    #
    # Wait. Tableau represents a Clifford operation C.
    # C maps Z basis to the Tableau basis.
    # If tableau.z_output(k) = S_k, then C * Z_k * C_dag = S_k.
    # Since Z_k stabilizes |0...0>, then S_k stabilizes C |0...0>.
    # So yes, we just need the circuit of the tableau.
    
    print("Generating circuit...")
    # Convert to standard gates (H, S, CX, etc.)
    # method="elimination" uses Gaussian elimination to synthesize the circuit.
    circuit = tableau.to_circuit(method="elimination")
    
    # Save to file
    with open("circuit_solution.stim", "w") as f:
        f.write(str(circuit))
    
    print("Circuit saved to circuit_solution.stim")

