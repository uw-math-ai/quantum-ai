import stim

def verify():
    print("Loading stabilizers...")
    with open('target_stabilizers_153.txt', 'r') as f:
        stabilizers = [line.strip() for line in f if line.strip()]
    
    print(f"Loading circuit...")
    with open('solve_153_circuit.stim', 'r') as f:
        circuit_text = f.read()
    
    circuit = stim.Circuit(circuit_text)
    print(f"Circuit loaded. {len(circuit)} instructions.")
    
    # We want to check if the circuit prepares a state stabilized by 'stabilizers'.
    # The circuit maps |0...0> to |psi>.
    # So U |0...0> = |psi>.
    # A Pauli P stabilizes |psi> iff U^dag P U stabilizes |0...0>.
    # The stabilizers of |0...0> are the group generated by Z0, Z1, ..., Zn.
    # So U^dag P U must be in <Z0, ..., Zn>.
    # This means U^dag P U must consist only of I and Z operators (no X or Y), and have +1 phase?
    # Actually, the phase matters. The stabilizer must be +1.
    # So U^dag P U must be +1 * (product of Zs).
    
    tableau = stim.Tableau.from_circuit(circuit)
    inverse_tableau = tableau.inverse()
    
    failed = 0
    for i, s_str in enumerate(stabilizers):
        s = stim.PauliString(s_str)
        
        # Apply inverse tableau to the stabilizer
        # The result is P' such that P = U P' U^dag => P' = U^dag P U
        conjugated = inverse_tableau(s)
        
        # Check if conjugated is made of I and Z only
        # We can check this by verifying that it commutes with all Z_k?
        # No, easier: check if X component is zero.
        # But stim doesn't expose components directly easily in python?
        # It does via .x_output, .z_output etc of tableau, but here we have a PauliString.
        # We can convert to numpy or string.
        
        # Check phase
        if conjugated.sign != +1:
            print(f"Stabilizer {i} failed: Phase is {conjugated.sign} (expected +1)")
            failed += 1
            continue
            
        # Check Pauli terms
        # For a PauliString, we can iterate or print it.
        # If it contains X or Y, it's not stabilized by |0...0>.
        # (Since Z_k stabilizes |0...0>, but X_k and Y_k do not).
        
        # Let's stringify and check
        conj_str = str(conjugated)
        # conj_str might look like "+ZIZ..." or "-X..."
        
        if 'X' in conj_str or 'Y' in conj_str:
            print(f"Stabilizer {i} failed: Conjugated to {conj_str} (contains X or Y)")
            failed += 1
            continue
            
    if failed == 0:
        print("SUCCESS: All stabilizers preserved.")
    else:
        print(f"FAILURE: {failed} stabilizers not preserved.")

if __name__ == "__main__":
    verify()
