import stim

def calculate_destabilizers():
    # Stabilizers
    s1 = stim.PauliString("XZZXI")
    s2 = stim.PauliString("IXZZX")
    s3 = stim.PauliString("XIXZZ")
    s4 = stim.PauliString("ZXIXZ")
    zl = stim.PauliString("ZZZZZ") # Z0 -> ZL
    
    # We need D1, D2, D3, D4, XL such that:
    # Dk anticommutes with Sk, commutes with others.
    # XL anticommutes with ZL, commutes with Sk.
    
    # XL is easy: XXXXX.
    xl = stim.PauliString("XXXXX")
    
    # Let's use stim to complete the tableau.
    # We have 5 commuting generators ZL, S1, S2, S3, S4.
    # We can use Tableau.from_stabilizers to find *some* destabilizers.
    generators = [zl, s1, s2, s3, s4]
    t = stim.Tableau.from_stabilizers(generators)
    
    # t.z_output(k) is the k-th generator.
    # t.x_output(k) is the k-th destabilizer.
    
    # However, the order might not match my input order.
    # Tableau.from_stabilizers might reorder or mix them.
    # But it guarantees the resulting stabilizer group is the same.
    # If I use this tableau to generate a circuit, it will prepare the state stabilized by {ZL, S1...S4}.
    # Which is |0_L>.
    # And the circuit implements the unitary U such that U Z_k U_dag = Stabilizer_k.
    # If I use this circuit, U |00000> -> |0_L>.
    
    # But does it map |psi> |0000> to |psi_L>?
    # This requires U X_0 U_dag = X_L.
    # If U is generated from `from_stabilizers`, U X_0 U_dag will be *some* destabilizer D_0.
    # If D_0 == X_L, then we are good.
    # If D_0 != X_L, then we might be implementing a different logical basis or operation.
    
    # Let's check what X_output(0) is for the tableau generated by `from_stabilizers([ZL, S1...S4])`.
    
    print(f"Z0 -> {t.z_output(0)}")
    print(f"X0 -> {t.x_output(0)}")
    
    # If X0 maps to something that acts like X_L on the code space, we are good.
    # X_L must anticommute with Z_L and commute with S1..S4.
    # Any such operator is equivalent to XXXXX up to multiplication by stabilizers.
    # Since we only care about the code space, equivalent logical operators are fine.
    # So actually, `from_stabilizers` is sufficient!
    
    # We just need to ensure ZL is the first stabilizer in the list passed to `from_stabilizers`,
    # so that it corresponds to Z_output(0).
    # Then input Z0 maps to ZL.
    # And input X0 maps to some XL' (which works as logical X).
    # So `from_stabilizers([ZL, S1, S2, S3, S4])` gives us the encoder U.
    # U maps Z0 -> ZL.
    # U maps Z1..Z4 -> S1..S4.
    # And implicitly handles X.
    
    print("Circuit:")
    print(t.to_circuit("elimination"))

if __name__ == "__main__":
    calculate_destabilizers()
