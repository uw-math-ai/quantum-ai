import stim
import itertools

def solve_block_prep():
    print("Finding circuit for 5-qubit block...")

    # Generators for the 5-qubit code (g0..g3)
    # The 5th generator determines the logical state.
    # To prepare logical |0>, we fix Z_L = ZZZZZ.
    # To prepare logical |+>, we fix X_L = XXXXX.
    
    # Let's try to prepare logical |0>.
    # Stabilizers: g0, g1, g2, g3, ZZZZZ
    stabs = [
        stim.PauliString("XZZXI"),
        stim.PauliString("IXZZX"),
        stim.PauliString("XIXZZ"),
        stim.PauliString("ZXIXZ"),
        stim.PauliString("ZZZZZ")
    ]
    
    # Find a tableau that maps Z0..Z4 to these stabilizers
    # Note: stim.Tableau.from_stabilizers creates a circuit that maps |0> to the stabilizer state.
    # This circuit maps Z_i inputs to S_i outputs? No, it maps output Z_i to input S_i?
    # Let's check documentation or experiment.
    # "Returns a Tableau which maps the Z basis states to the given stabilizers."
    # So T(Z_i) = S_i.
    
    t = stim.Tableau.from_stabilizers(stabs)
    circ = t.to_circuit()
    
    print("Circuit found:")
    print(circ)
    
    # Verify logical X
    # X4 is the destabilizer corresponding to Z4.
    # So T(X4) should be a logical X operator.
    # Logical X for [[5,1,3]] is usually XXXXX.
    lx = t.x_output(4)
    print(f"Logical X (image of X4): {lx}")
    
    # Check if lx is equivalent to XXXXX modulo stabilizers.
    # lx * XXXXX should be in the stabilizer group (generated by g0..g3, ZZZZZ).
    # Actually, lx must anticommute with ZZZZZ. Yes.
    # And commute with g0..g3.
    
    # Let's check commutation with g0..g3
    for i in range(4):
        g = stabs[i]
        c = lx.commutes(g)
        print(f"Commutes with g{i}: {c}")

solve_block_prep()
