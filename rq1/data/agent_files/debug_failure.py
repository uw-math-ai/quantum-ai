import stim
import sys

def analyze_failure():
    with open("target_stabilizers_102.txt", "r") as f:
        target_stabilizers = [line.strip() for line in f if line.strip()]

    # Load the circuit
    with open("circuit_102.stim", "r") as f:
        circuit_str = f.read()
    circuit = stim.Circuit(circuit_str)
    
    # Calculate the stabilizer of the state prepared by the circuit
    # Start with |0...0>
    tableau = stim.Tableau.from_circuit(circuit)
    
    # Check each target stabilizer
    print("Checking stabilizers...")
    failed = []
    for i, s in enumerate(target_stabilizers):
        p = stim.PauliString(s)
        # We need to check if the state is a +1 eigenstate of p
        # The state is stabilized by tableau(Z_k)
        # So p must be in the group generated by {tableau(Z_0), ..., tableau(Z_101)}
        # But since we started with 0 state, the stabilizers are exactly the Z outputs of the tableau.
        # Wait, if we start with |0> state, the stabilizers are +Z_0, ..., +Z_n.
        # After applying circuit U, the stabilizers are U Z_0 U^dag, ..., U Z_n U^dag.
        # These are exactly the Z outputs of the tableau if the tableau represents U.
        # Let's verify if p is in the group generated by these.
        
        # However, checking group membership is hard if we don't assume they are the generators.
        # But we can just measure the expectation value.
        # If the state is stabilized by p, expectation is +1.
        # We can use tableau(p).
        # If tableau represents U, then we want <0| U^dag P U |0>.
        # U^dag P U is the observable P evolved backwards by U.
        # In Stim tableau, `tableau(P)` usually means P evolved by the tableau operation.
        # So we want `tableau.inverse()(P)`. Let's check the expectation of that against |0>.
        # <0| tableau.inverse()(P) |0>.
        # This is +1 if the resulting Pauli string consists only of I and Z and has + sign.
        
        t_inv = tableau.inverse()
        p_inv = t_inv(p)
        
        # Check if p_inv stabilizes |0>.
        # It must have no X or Y components.
        if not (p_inv.x_int == 0 and p_inv.z_int != 0): # wait, Z_int can be anything?
             # For |0...0>, the stabilizers are Z_i.
             # The group is generated by Z_i. Elements are products of Z_i.
             # So p_inv must be a product of Z_i's with phase +1.
             # This means p_inv must have only I and Z terms (x_int == 0) and sign +1.
             pass

        if p_inv.x_int != 0:
             # Has X or Y part -> expectation 0 -> not stabilized
             print(f"Stabilizer {i} failed: Not stabilized (has X/Y components in inverse)")
             failed.append(i)
        elif p_inv.sign == -1:
             print(f"Stabilizer {i} failed: Anti-stabilized (sign -1)")
             failed.append(i)
        elif p_inv.sign == 1j or p_inv.sign == -1j:
             print(f"Stabilizer {i} failed: Complex phase")
             failed.append(i)

    print(f"Total failed: {len(failed)}")

if __name__ == "__main__":
    analyze_failure()
