import stim

def generate_513_encoder():
    # We want a circuit that maps |psi> |0000> -> Encoded |psi>
    # The stabilizers of the code are XZZXI cyclic.
    # Logical operators: ZL = ZZZZZ, XL = XXXXX.
    # We want to preserve ZL and XL.
    # i.e. input Z on qubit 0 -> output ZZZZZ
    # input X on qubit 0 -> output XXXXX
    
    # We can use Tableau.from_stabilizers.
    # We define the stabilizers of the OUTPUT state assuming input is |0...0>.
    # Wait, no. We want a unitary.
    # Let's define the tableau of the unitary U.
    # U maps Z_input_0 -> Z_L = ZZZZZ
    # U maps X_input_0 -> X_L = XXXXX
    # U maps Z_input_k -> S_k (for k=1..4) (stabilizers)
    # U maps X_input_k -> D_k (destabilizers)
    
    # The stabilizers are:
    # S1: XZZXI
    # S2: IXZZX
    # S3: XIXZZ
    # S4: ZXIXZ
    
    # We need to find D1..D4.
    # But stim can find a circuit to prepare a state.
    # If we find a circuit that prepares the +1 eigenstate of {Z_L, S1, S2, S3, S4},
    # that circuit maps |0...0> to |0_L>.
    # But we want to map |psi> to |psi_L>.
    # If the circuit consists of Cliffords, and maps |0> to |0_L> and |1> to |1_L>, it works.
    # The state stabilized by {Z_L, S...} is |0_L>.
    # The state stabilized by {-Z_L, S...} is |1_L>.
    
    # So if we find a circuit C that prepares |0_L>, does it map X to X_L?
    # Not necessarily. It might map X to -X_L or Y_L.
    # However, for [5,1,3], usually the standard preparation works.
    
    # Let's try to find a circuit that prepares the code state with Z_L=+1.
    stabilizers = [
        "XZZXI",
        "IXZZX",
        "XIXZZ",
        "ZXIXZ",
        "ZZZZZ" # Logical Z
    ]
    t = stim.Tableau.from_stabilizers([stim.PauliString(s) for s in stabilizers])
    circ = t.to_circuit("elimination")
    
    # This circuit prepares |0_L> from |00000>.
    # To encode |psi>, we can assume input 0 is |psi> and 1..4 are |0>.
    # But the circuit generated by `from_stabilizers` assumes starting from |0...0>.
    # It consists of H, CNOT, S, etc.
    # We want to modify it so that it acts on |psi> correctly.
    # Actually, `to_circuit("elimination")` produces a circuit that essentially does:
    # Initialize |0...0>
    # Apply unitary U
    # But we don't have |0> on qubit 0. We have |psi>.
    # If the first operations on qubit 0 are initialization or measurements, that destroys |psi>.
    # `elimination` method often produces circuits with M and R (reset).
    # We need a unitary circuit (no reset/measurement on input).
    
    # Since [5,1,3] is a stabilizer code, there is a unitary encoding circuit.
    # Let's search for "5 qubit code encoding circuit".
    # Or derive it.
    # A simple encoder for [5,1,3]:
    # 1. H 0,1,2,3,4? No.
    # A graph state encoder is simpler.
    # [5,1,3] is equivalent to a graph state ring of 5 + local cliffords?
    # Yes, 5-cycle graph state.
    # Graph: 0-1-2-3-4-0.
    # Stabilizers of graph state: X_i * Prod_{j in N(i)} Z_j.
    # 0: X0 Z1 Z4
    # 1: Z0 X1 Z2
    # 2: Z1 X2 Z3
    # 3: Z2 X3 Z4
    # 4: Z0 Z3 X4
    # Target stabilizers: XZZXI (X0 Z1 Z2 X3 I4)
    # This is not the graph state directly.
    # But it's LC equivalent.
    
    # Alternatively, use Stim to find the unitary.
    # U * Z0 * U_dag = ZZZZZ
    # U * X0 * U_dag = XXXXX
    # U * Z1 * U_dag = XZZXI
    # U * Z2 * U_dag = IXZZX
    # U * Z3 * U_dag = XIXZZ
    # U * Z4 * U_dag = ZXIXZ
    
    # We can solve for U using `stim.Tableau.from_conjugated_generators`.
    # This is exactly what we need!
    
    # Input generators: Z0, X0, Z1, Z2, Z3, Z4
    # Output generators: ZZZZZ, XXXXX, XZZXI, IXZZX, XIXZZ, ZXIXZ
    # Wait, we need to match X/Z pairs for inputs.
    # Input X1..X4 -> don't care (destabilizers).
    # But we must provide full tableau or compatible set.
    # Actually, we can just specify the Z's and X's we care about?
    # No, `from_conjugated_generators` needs full generators for Clifford?
    # Or at least a set that defines the Clifford.
    
    # Let's define:
    # Z0 -> ZZZZZ
    # X0 -> XXXXX
    # Z1 -> XZZXI
    # Z2 -> IXZZX
    # Z3 -> XIXZZ
    # Z4 -> ZXIXZ
    # We need to ensure the output generators have the same commutation relations as input.
    # Inputs: All Z's commute. X0 anticommutes with Z0. X0 commutes with Z1..Z4.
    # Outputs:
    # ZZZZZ commutes with XZZXI? ZZZZZ has Z everywhere. XZZXI has X at 0,3. Two X's. Commutes.
    # ZZZZZ commutes with all stabilizers (it's logical Z).
    # XXXXX anticommutes with ZZZZZ? 5 anticommutations -> anticommutes. Correct.
    # XXXXX commutes with stabilizers? XXXXX vs XZZXI. Z at 1,2. Two Z's. Commutes.
    # Stabilizers commute with each other? We verified this.
    # So the commutation relations match.
    # We don't care what X1..X4 map to (they are gauge/destabilizers).
    # Stim allows underconstrained if we don't specify them.
    
    t = stim.Tableau.from_conjugated_generators(
        xs=[stim.PauliString("X____")],
        zs=[stim.PauliString("Z____"), 
            stim.PauliString("_Z___"), 
            stim.PauliString("__Z__"), 
            stim.PauliString("___Z_"), 
            stim.PauliString("____Z")],
        x_outputs=[stim.PauliString("XXXXX")],
        z_outputs=[stim.PauliString("ZZZZZ"),
                   stim.PauliString("XZZXI"),
                   stim.PauliString("IXZZX"),
                   stim.PauliString("XIXZZ"),
                   stim.PauliString("ZXIXZ")]
    )
    return t.to_circuit("elimination")

def generate_outer_circuit():
    # 9 qubits.
    # Stabilizers:
    # Z0Z1, Z0Z2
    # Z3Z4, Z3Z5
    # Z6Z7, Z6Z8
    # X0X1X2X3X4X5
    # X0X1X2X6X7X8
    # Z0Z3Z6 (chosen to fix the state)
    
    stabs = [
        "ZZIIIIIII",
        "ZIZIIIIII",
        "IIIZZIIII",
        "IIIZIZIII",
        "IIIIIIZZI",
        "IIIIIIZIZ",
        "XXXXXXIII",
        "XXXIIIXXX",
        "ZIIZIIZII"
    ]
    t = stim.Tableau.from_stabilizers([stim.PauliString(s) for s in stabs])
    return t.to_circuit("elimination")

def combine():
    encoder = generate_513_encoder()
    outer = generate_outer_circuit()
    
    # Outer circuit produces state on 0..8.
    # We want to expand this to 45 qubits.
    # Each qubit k (0..8) becomes a block of 5 (5k..5k+4).
    # The encoder takes qubit 0 (input) and 1..4 (ancilla |0>) and outputs 5 qubits.
    # But `encoder` circuit assumes it acts on 0,1,2,3,4.
    
    # So the full circuit:
    # 1. Run `outer` on qubits 0, 5, 10, 15, 20, 25, 30, 35, 40.
    #    Wait, `outer` uses 0..8. We should relabel its qubits to be the "leaders" of each block.
    #    Let's map outer qubit k -> physical qubit 5*k.
    
    # 2. For each block k=0..8:
    #    Apply `encoder` on qubits 5k, 5k+1, 5k+2, 5k+3, 5k+4.
    #    But `encoder` expects inputs on 0 (data) and 1..4 (ancilla |0>).
    #    Qubit 5k already has the data from `outer`.
    #    Qubits 5k+1..5k+4 are initialized to |0> (at start of circuit).
    #    So we just apply the encoder operations shifted to the block.
    
    full_circuit = stim.Circuit()
    
    # Add outer circuit with remapping
    # Remap k -> 5*k
    qm = {k: 5*k for k in range(9)}
    
    # We need to parse `outer` and remap.
    # `outer` might contain complex gates.
    # Iterating instructions and remapping targets.
    for instr in outer:
        targets = []
        for t in instr.targets_copy():
            if t.is_qubit_target:
                targets.append(t.value * 5)
            else:
                targets.append(t) # Measurement targets etc?
        # Reconstruct instruction
        full_circuit.append(instr.name, targets, instr.gate_args)
        
    # Add encoders
    for k in range(9):
        offset = 5*k
        # Encoder acts on 0..4. Map to offset..offset+4.
        for instr in encoder:
            targets = []
            for t in instr.targets_copy():
                if t.is_qubit_target:
                    targets.append(t.value + offset)
                else:
                    targets.append(t) 
            full_circuit.append(instr.name, targets, instr.gate_args)
            
    # The circuit uses up to qubit 44 (last block 40..44).
    # The problem has 49 qubits. 45..48 are unused.
    # We should initialize them or just leave them (they start at |0>).
    # The stabilizers for them?
    # The stabilizers list has 48 stabilizers.
    # 36 (local) + 8 (global) = 44 stabilizers.
    # Where are the other 4?
    # Check `stabilizers_49_v2.txt` again.
    # Count lines.
    
    print(full_circuit)

if __name__ == "__main__":
    combine()
