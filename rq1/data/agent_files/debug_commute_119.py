import stim
import networkx as nx

def solve():
    with open("target_stabilizers_119_v2.txt", "r") as f:
        stabilizers = [line.strip() for line in f if line.strip()]

    # Convert stabilizers to a Tableau
    # We want to find a graph state equivalent to this stabilizer state.
    # A graph state is stabilized by X_i Z_N(i) where N(i) are neighbors.
    # We can use `stim.Tableau.from_stabilizers` then convert to graph state?
    # No direct method in stim to convert to graph state.
    
    # Alternative: Use `stim.Tableau.to_circuit("MPP")` then convert MPP to unitary?
    # MPP uses measurements. We want unitary.
    
    # Let's retry the elimination approach but check if we need to account for signs.
    # The stabilizers are all +1.
    # The tableau stores the signs.
    
    # Maybe the issue is that "elimination" method simplifies the tableau but might not produce the exact inverse needed for state prep if the tableau isn't full rank?
    # But 119 stabilizers for 119 qubits. It should be full rank.
    
    # Let's check the rank.
    tableau = stim.Tableau.from_stabilizers([stim.PauliString(s) for s in stabilizers], allow_underconstrained=True)
    # If len(stabilizers) == 119, it should be full rank.
    
    # Try "Gaussian" method instead of elimination? "gaussian" is not a method.
    # Methods: 'elimination', 'mpp-state', 'mpp-measure'.
    # 'mpp-state' prepares the state using measurements.
    
    # If we want a unitary circuit, we can try to synthesize it.
    # Stim has `stim.Circuit.from_tableau`? No.
    # But `tableau.to_circuit` has limited methods.
    
    # Let's try to construct the circuit by diagonalizing the stabilizers manually.
    # This is effectively what Gaussian elimination does.
    # But maybe `to_circuit("elimination")` is doing CNOTs to eliminate X components, then H to swap X/Z?
    
    # Let's try using `to_circuit("elimination")` but without inverting, just to see what it does.
    # It maps the state to |0>.
    # So if we run `circuit.inverse()` on |0>, we should get the state.
    # This is what we did.
    
    # Why did it fail?
    # Maybe the stabilizers provided are not consistent?
    # Let's check consistency.
    
    # Also, maybe the graph state approach is better.
    # We can build the adjacency matrix.
    # But finding the LC (Local Clifford) transformation to a graph state is non-trivial.
    
    # Let's try `stim.Tableau.from_stabilizers` again, but this time ensure we are using the right method.
    # Maybe the issue is the order of qubits?
    
    # Another possibility: The stabilizers provided might be dependent, so we have free qubits.
    # If expectation is 0, it means the state is not stabilized by it.
    # If the state is stabilized by -S, expectation is -1.
    # If 0, it means it's random outcome for measurement of S.
    
    # Let's try to use the `check_stabilizers_tool` directly with the circuit we have, just to be sure my local check isn't buggy.
    # But my local check is using stim directly, which is reliable.
    
    # Let's try a different approach.
    # We can iteratively correct the state.
    # But that's hard with 119 qubits.
    
    # Let's use the property that `to_circuit("elimination")` produces a circuit that sends the stabilizers to Z_i.
    # S_i -> Z_k.
    # If we invert, Z_k -> S_i.
    # But which Z_k?
    # If the stabilizers are ordered, maybe it maps S_i to Z_i?
    # The `elimination` might reorder things.
    # But if we prepare |0...0> which is stabilized by Z_0...Z_118.
    # And the circuit U maps Z_k to S'_k (some reordered set).
    # Then the state U|0> is stabilized by {S'_k}.
    # If {S'_k} is the same set as {S_i}, then we are good.
    # But if `elimination` only guarantees that the span is correct, it should be fine.
    
    # Wait, expectation 0 means the state is NOT stabilized by S.
    # This means S is NOT in the group generated by {S'_k}.
    # This implies U|0> is stabilized by a DIFFERENT group.
    
    # This happens if `to_circuit("elimination")` creates a circuit that reduces the tableau to identity, but maybe it assumes something about the input.
    # "elimination" circuit C satisfies C(Tableau) = IdentityTableau.
    # i.e., C * Stabilizers * C^dag = {Z_i}.
    # So C Stabilizers C^dag = Z_i.
    # => Stabilizers = C^dag Z_i C.
    # So C^dag on |0> (stabilized by Z_i) should produce state stabilized by Stabilizers.
    # This logic holds.
    
    # So why does it fail?
    # Maybe `to_circuit("elimination")` does NOT map stabilizers to Z_i?
    # The doc says "Returns a circuit that performs Gaussian elimination to reduce the tableau to the identity tableau."
    # If the tableau represents the stabilizers, then reducing it to identity means mapping stabilizers to Z operators.
    # Yes.
    
    # Is it possible the stabilizers are anti-commuting?
    # If so, no state exists.
    # Let's check commutation in the python script.
    
    tableau = stim.Tableau.from_stabilizers([stim.PauliString(s) for s in stabilizers], allow_underconstrained=True)
    
    # Check if they commute
    # We can check commutation of the provided strings.
    for i in range(len(stabilizers)):
        for j in range(i+1, len(stabilizers)):
            s1 = stim.PauliString(stabilizers[i])
            s2 = stim.PauliString(stabilizers[j])
            if not s1.commutes(s2):
                print(f"Stabilizers {i} and {j} anti-commute!")
                return

    print("All stabilizers commute.")
    
    # If they commute, maybe the rank is low?
    print(f"Number of stabilizers: {len(stabilizers)}")
    # If they are independent, we should have 119.
    
    # Let's try to debug the circuit generation.
    # We used `tableau.to_circuit("elimination").inverse()`.
    # Let's try `tableau.inverse().to_circuit("elimination")`? No.
    
    # Let's try to use the `MPP` method to generate a state preparation circuit using measurements (if allowed).
    # "You may use additional ancilla qubits if helpful".
    # But usually we want a unitary.
    
    # Wait! The "elimination" output circuit might perform measurements?
    # No, I checked the output, it has no measurements.
    
    # What if I use `to_circuit("active-renormalization")`? No such method.
    
    # Let's try a different strategy.
    # The problem might be that the tableau created by `from_stabilizers` has X and Z components.
    # When we call `to_circuit("elimination")`, it clears the X components first?
    
    # Let's verify if `tableau` itself is correct.
    # The tableau stores `xs`, `zs`.
    # `from_stabilizers` puts the stabilizers into the `zs` of the tableau?
    # Or `xs`?
    # Actually, a stabilizer tableau represents a state where the stabilizers are the Z generators (destabilizers are X).
    # `from_stabilizers` sets the Z output of the tableau to be the stabilizers.
    # i.e., Tableau(Z_i) = S_i.
    # `to_circuit("elimination")` gives U such that U * Tableau = Identity.
    # i.e. U * S_i * U^dag = Z_i.
    # So U S_i U^dag = Z_i.
    # This implies S_i = U^dag Z_i U.
    # So the state stabilized by S_i is U^dag |0>.
    # This logic is robust.
    
    # Is it possible that `from_stabilizers` sets the stabilizers to X_i?
    # No, standard convention is Z.
    
    # Let's check which stabilizers failed again.
    # Stabilizer 3, 4, 5, 6, 10, ...
    # They seem random.
    
    # Maybe the `check_local_119.py` has a bug?
    # `sim.peek_observable_expectation(s)` returns the expectation value.
    # It returns 0 if the state is not an eigenstate.
    
    # Could it be that `stim.Tableau.from_stabilizers` reorders the stabilizers?
    # No, it should respect the list.
    
    # Let's try to use the graph state decomposition from the hints.
    # "Graph-state decomposition with local Cliffords"
    
if __name__ == "__main__":
    solve()
