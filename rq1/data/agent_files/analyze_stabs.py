import stim

stabilizers = [
    "IIXIIXIIXXIIIIIIIII",
    "IIIIIIIIIIXIXIIIIXX",
    "IIIIIIIIIIXXIXIIIIX",
    "XXIIIIIIIIIIIIXXIII",
    "XXIXXIXIIIIIIIIIXII",
    "IIXIXIIIXIIIIIIIXII",
    "IXIIIIXXIIIIIIIXIII",
    "IIIXIIXXIIXXXIIIIII",
    "IIIXXIIIXXIXIXIIIII",
    "IIZIIZIIZZIIIIIIIII",
    "IIIIIIIIIIZIZIIIIZZ",
    "IIIIIIIIIIZZIZIIIIZ",
    "ZZIIIIIIIIIIIIZZIII",
    "ZZIZZIZIIIIIIIIIZII",
    "IIZIZIIIZIIIIIIIZII",
    "IZIIIIZZIIIIIIIZIII",
    "IIIZIIZZIIZZZIIIIII",
    "IIIZZIIIZZIZIZIIIII"
]

# Check commutativity and properties
def check_commutativity(stabs):
    n = len(stabs[0])
    def to_pauli(s):
        x = 0
        z = 0
        for i, c in enumerate(s):
            if c in 'XZY':
                if c in 'XY': x |= (1 << i)
                if c in 'ZY': z |= (1 << i)
        return x, z

    paulis = [to_pauli(s) for s in stabs]
    
    commutes = True
    for i in range(len(paulis)):
        for j in range(i + 1, len(paulis)):
            x1, z1 = paulis[i]
            x2, z2 = paulis[j]
            # Anti-commute if parity of bits where one has X and other has Z is odd
            # comm = (x1 & z2) ^ (z1 & x2)
            # popcount
            comm_val = bin((x1 & z2) ^ (z1 & x2)).count('1') % 2
            if comm_val != 0:
                print(f"Generators {i} and {j} anti-commute!")
                commutes = False
    return commutes

print(f"Number of stabilizers: {len(stabilizers)}")
print(f"Number of qubits: {len(stabilizers[0])}")
print(f"Commutes: {check_commutativity(stabilizers)}")

# Analyze structure
# It looks like 9 X-only generators and 9 Z-only generators.
# Let's verify.
x_gens = stabilizers[:9]
z_gens = stabilizers[9:]

print("First 9 are X-only:", all(all(c in 'IX' for c in s) for s in x_gens))
print("Last 9 are Z-only:", all(all(c in 'IZ' for c in s) for s in z_gens))

# If they are CSS codes (X and Z generators separated), we can treat them separately.
# However, for 19 qubits and 18 generators, we might be missing one, or it's a logical qubit encoding (19-18=1 logical qubit).
# The prompt asks to prepare a state that is a +1 eigenstate of EVERY provided generator.
# If it's a logical state, we might have freedom on the last logical operator.
# Usually 'prepare the stabilizer state' implies the +1 eigenstate of the maximal abelian subgroup generated by these.
# If it's 18 generators for 19 qubits, it is a subspace of dimension 2.
# Any state in that subspace is a valid answer?
# "The final quantum state ... must be a +1 eigenstate of every provided stabilizer generator."
# Yes. So we can arbitrarily fix the logical operator to be +1 or just leave it.
# BUT check_stabilizers_tool takes a circuit and stabilizers.
# If the circuit prepares a pure state (19 stabilizers), and that state is in the +1 subspace of the 18 generators, it should return True for all.
# So I can just add a 19th stabilizer to complete it, or just find a circuit for the 18.
# Actually, if I prepare a pure state |psi>, and check it against the 18 stabilizers, if |psi> is stabilized by them, it passes.
