
import stim
import sys

def check_commutativity(stabilizers):
    for i in range(len(stabilizers)):
        for j in range(i + 1, len(stabilizers)):
            s1 = stabilizers[i]
            s2 = stabilizers[j]
            commute = s1 * s2 == s2 * s1
            if not commute:
                print(f"Stabilizers {i} and {j} do not commute!")
                print(f"S{i}: {s1}")
                print(f"S{j}: {s2}")
                return False
    return True

def main():
    with open("stabilizers_100.txt", "r") as f:
        lines = [l.strip() for l in f.readlines() if l.strip()]

    stabilizers = [stim.PauliString(s) for s in lines]
    n_qubits = len(stabilizers[0])
    n_stabs = len(stabilizers)

    print(f"Qubits: {n_qubits}")
    print(f"Stabilizers: {n_stabs}")

    if not check_commutativity(stabilizers):
        print("Stabilizers do not commute.")
        return

    print("Stabilizers commute.")

    # Check independence
    # We can use Gaussian elimination to check rank.
    # Stim's Tableau.from_stabilizers(stabilizers) creates a Tableau.
    # If the stabilizers are not independent or not maximal, it might complain or fill in the rest.
    # Actually, from_stabilizers requires n stabilizers.
    
    if n_stabs < n_qubits:
        print(f"Only {n_stabs} stabilizers. Need to add {n_qubits - n_stabs} more.")
        
        # We need to find stabilizers that commute with all existing ones and are independent.
        # Since the existing ones commute, we just need to find S_new such that [S_new, S_i] = 0 for all i
        # and S_new is not in the group generated by S_i.
        
        # We can try single qubit Z's or X's.
        # But brute force might be slow if we check independence by full Gaussian elimination every time.
        # However, for 100 qubits it's fast.
        
        additional_candidates = []
        for q in range(n_qubits):
            additional_candidates.append(stim.PauliString("I"*q + "Z" + "I"*(n_qubits-q-1)))
            additional_candidates.append(stim.PauliString("I"*q + "X" + "I"*(n_qubits-q-1)))
            
        added_count = 0
        current_stabilizers = list(stabilizers)
        
        for cand in additional_candidates:
            if added_count == n_qubits - n_stabs:
                break
                
            # Check commutation with all current stabilizers
            commutes_all = True
            for s in current_stabilizers:
                if not s.commutes(cand):
                    commutes_all = False
                    break
            
            if commutes_all:
                # Check independence
                # We can check independence by trying to form a Tableau with the new set.
                # If it fails, it might be dependent.
                # A better way is to use Gaussian elimination on the check matrix.
                # But let's try a simpler way: if we can form a Tableau with the current + candidate, it's independent?
                # No, from_stabilizers requires exactly N.
                
                # Let's just try to add it and see if we can eventually reach N.
                # We need a robust way to check linear independence.
                pass
                
        # Better approach:
        # 1. Convert to boolean matrix (2N cols, K rows).
        # 2. Gaussian elimination to row echelon form.
        # 3. Find vectors orthogonal to the rows (symplectic inner product) to find the logical operators?
        # Actually, we just need to extend the stabilizer group to a maximal one.
        
        # Let's use the property that we can start with the tableau of |0...0> (stabilizers Z_i)
        # and measure the given stabilizers.
        # If we measure a stabilizer and get +1 (or -1), we project onto it.
        # If we measure all of them, the resulting state will be stabilized by them.
        # And since we started with a pure state, the final state is pure.
        # The resulting state will be stabilized by the measured stabilizers (and some of the original Z_i's or modified versions).
        # BUT: we need the measurement results to be +1.
        # If we measure and get -1, we need to apply a correction.
        # Stim can simulate this!
        
        print("Using measurement-based preparation strategy...")
        
        # Strategy:
        # 1. Start with |0...0>
        # 2. Measure each stabilizer S_i.
        # 3. If outcome is -1, apply a correction.
        #    Wait, finding the correction is hard in general without the tableau structure.
        #    But actually, if we just use the Tableau simulator, we can track the state.
        
        sim = stim.TableauSimulator()
        # The simulator starts in |0...0>
        
        # We can't just "measure and force outcome".
        # But we can "measure" and if it's -1, we record that we need to flip it.
        # BUT we need a circuit that *deterministically* prepares +1.
        
        # Let's go back to completing the basis.
        import numpy as np
        
        def to_check_matrix(stabs, n):
            # n qubits -> 2n columns (X then Z)
            mat = np.zeros((len(stabs), 2*n), dtype=bool)
            for i, s in enumerate(stabs):
                for k in range(n):
                    p = s[k]
                    if p == 1 or p == 2: # X or Y
                        mat[i, k] = 1
                    if p == 3 or p == 2: # Z or Y
                        mat[i, k + n] = 1
            return mat

        # We can use Gaussian elimination to check independence.
        
        # Let's try to add candidates that are independent.
        # We'll maintain a list of independent stabilizers.
        independent_stabs = []
        
        # Add original stabilizers one by one, verifying independence
        # (They should be independent, but good to check)
        
        # Actually, let's use the tableau algorithm logic directly.
        # If we have K independent commuting stabilizers, we can extend them to N.
        
        # Let's try to identify 2 simple Paulis that complete the set.
        # We can try random Paulis or single-qubit Paulis.
        
        # Let's try a randomized approach to find the missing 2.
        import random
        
        candidates = []
        # Add single qubit Zs and Xs
        for i in range(n_qubits):
            s = ["I"] * n_qubits
            s[i] = "Z"
            candidates.append(stim.PauliString("".join(s)))
            s[i] = "X"
            candidates.append(stim.PauliString("".join(s)))
            
        current_stabs = list(stabilizers)
        
        # Filter candidates to those that commute with all current_stabs
        commuting_candidates = []
        for cand in candidates:
            if all(cand.commutes(s) for s in current_stabs):
                commuting_candidates.append(cand)
                
        print(f"Found {len(commuting_candidates)} candidates that commute with all stabilizers.")
        
        # Now pick ones that increase the rank.
        # We need a function to check rank.
        
        def get_rank(stabs_list):
             # Basic Gaussian elimination over GF(2)
             if not stabs_list:
                 return 0
             m = to_check_matrix(stabs_list, n_qubits)
             # Gaussian elimination
             rows, cols = m.shape
             pivot_row = 0
             for j in range(cols):
                 if pivot_row >= rows:
                     break
                 # Find pivot
                 pivot = -1
                 for i in range(pivot_row, rows):
                     if m[i, j]:
                         pivot = i
                         break
                 if pivot == -1:
                     continue
                 
                 # Swap
                 m[[pivot_row, pivot]] = m[[pivot, pivot_row]]
                 
                 # Eliminate
                 for i in range(rows):
                     if i != pivot_row and m[i, j]:
                         m[i] ^= m[pivot_row]
                 
                 pivot_row += 1
             return pivot_row

        current_rank = get_rank(current_stabs)
        print(f"Current rank: {current_rank}")
        
        if current_rank < len(current_stabs):
             print("Warning: Original stabilizers are not independent!")
             # We should prune dependent ones?
             # But if they are consistent, it's fine.
             pass
             
        # Try adding candidates
        for cand in commuting_candidates:
            if len(current_stabs) == n_qubits:
                break
            # Check if adding this increases rank
            test_list = current_stabs + [cand]
            if get_rank(test_list) > current_rank:
                current_stabs.append(cand)
                current_rank += 1
                print(f"Added stabilizer. New rank: {current_rank}")
                
        if len(current_stabs) == n_qubits:
             print("Successfully found 100 independent commuting stabilizers.")
             try:
                t = stim.Tableau.from_stabilizers(current_stabs)
                c = t.to_circuit()
                print("Generated circuit.")
                with open("circuit_100.stim", "w") as f:
                    f.write(str(c))
             except Exception as e:
                print(f"Error: {e}")
        else:
             print(f"Could not complete the set. Stuck at {len(current_stabs)} stabilizers.")

    elif n_stabs == n_qubits:
        print("Number of stabilizers equals number of qubits. Attempting to generate tableau directly.")
        try:
            t = stim.Tableau.from_stabilizers(stabilizers)
            c = t.to_circuit()
            print("Circuit generated successfully.")
            with open("circuit_100.stim", "w") as f:
                f.write(str(c))
        except Exception as e:
            print(f"Error generating tableau: {e}")
    else:
        print(f"Number of stabilizers ({n_stabs}) is not equal to number of qubits ({n_qubits}).")
        # If we have fewer stabilizers, we can pad with Z operators on the remaining degrees of freedom?
        # Or just use the ones we have and let Stim fill it if possible?
        # stim.Tableau.from_stabilizers requires len(stabilizers) == num_qubits.
        
        # If n_stabs < n_qubits, we can try to add dummy stabilizers.
        # But we need to make sure they commute with everything and each other.
        pass

if __name__ == "__main__":
    main()
