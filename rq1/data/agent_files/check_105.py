import stim
import sys

def check():
    with open('stabilizers_105.txt', 'r') as f:
        stabilizers = [l.strip() for l in f if l.strip()]
    
    with open('circuit_105.stim', 'r') as f:
        circuit_text = f.read()
    
    c = stim.Circuit(circuit_text)
    
    # Check if the circuit prepares the state stabilized by the stabilizers
    # We can check if P * State = State for each P in stabilizers
    # Or simpler: evolve the Pauli strings P by the inverse of the circuit C^-1.
    # If C |0> is the state, then C^-1 maps the state to |0>.
    # So C^-1 P C should be Z_i or product of Zs?
    # No, C |0> is stabilized by S_i.
    # So C Z_i C^-1 = S_i? No.
    # The stabilizers of |0> are Z_0, Z_1, ...
    # So the stabilizers of C|0> are C Z_0 C^-1, C Z_1 C^-1, ...
    # This means the group generated by {S_i} should be the same as the group generated by {C Z_i C^-1}.
    
    # Alternatively, use Tableau.
    t = stim.Tableau.from_circuit(c)
    
    # Check if each stabilizer S_i acts trivially on the state prepared by the circuit.
    # State is C|0>.
    # S_i C |0> = C |0>  <=>  C^-1 S_i C |0> = |0>
    # So we need C^-1 S_i C to be in the stabilizer group of |0>, which is generated by Zs.
    # i.e. C^-1 S_i C should be a product of Z operators (and identity), with +1 phase.
    
    correct_count = 0
    total_count = len(stabilizers)
    
    for s_str in stabilizers:
        s = stim.PauliString(s_str)
        # Conjugate by inverse of tableau
        # T represents C.
        # We want C^-1 S C.
        # T.inverse() represents C^-1?
        # T(P) = C P C^-1.
        # We want C^-1 S C.
        # Let P' = C^-1 S C. Then C P' C^-1 = S. So T(P') = S.
        # So P' = T^-1(S).
        
        # But wait, does stim.Tableau.from_circuit(c) represent C?
        # Yes.
        # So we need to check if T^-1(S) consists only of I and Z and has +1 sign.
        
        # Actually, if the circuit was constructed using `from_stabilizers`, it should be correct by construction.
        # But let's verify.
        
        inv_s = t.inverse_x_output_pauli(0) # Wait, inverse method might be complex.
        # T has an inverse method.
        inv_t = t.inverse()
        mapped_s = inv_t(s)
        
        # Check if mapped_s is all Zs and Is
        # PauliString has .x, .z bits.
        # We want x bits to be 0.
        # And sign to be +1.
        
        is_z = not np.any(mapped_s.x) # Need numpy or check string representation
        # string representation
        mapped_str = str(mapped_s)
        
        # Check if any X or Y.
        if 'X' in mapped_str or 'Y' in mapped_str:
             pass # Fail
        else:
             # Check sign.
             if mapped_s.sign == 1:
                 correct_count += 1
    
    print(f"Preserved: {correct_count}/{total_count}")

if __name__ == "__main__":
    import numpy as np # Stim uses numpy internally usually?
    # Stim objects can handle this.
    check()
