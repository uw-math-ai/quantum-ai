import stim
import sys
import os
import random

def solve_stabilizers(stabilizers_file, output_file):
    with open(stabilizers_file, 'r') as f:
        lines = [line.strip().replace(',', '') for line in f.readlines() if line.strip()]
    
    stabilizers = []
    for i, s in enumerate(lines):
        if len(s) < 171:
            s = s + 'I' * (171 - len(s))
        elif len(s) > 171:
            s = s[:171]
        ps = stim.PauliString(s)
        if len(ps) != 171:
            print(f"Error: Stabilizer {i} has length {len(ps)}")
        stabilizers.append(ps)
    
    if not stabilizers:
        print("No stabilizers loaded.")
        return
        
    n = len(stabilizers[0]) # 171
    n = len(stabilizers[0]) # 171
    print(f"Loaded {len(stabilizers)} stabilizers for {n} qubits.")
    
    # We have 151 stabilizers. We need 171.
    # We will try to add Z_k for k=0..170.
    # If Z_k commutes with all and is independent, we add it.
    
    # Filter base stabilizers for independence
    print("Filtering base stabilizers for independence...")
    independent_stabilizers = []
    
    # We use binary conversion and incremental rank check
    # But to be efficient, we maintain the basis in binary form?
    # Or just re-run GE.
    # For 151 it's fast enough.
    
    current_binary_rows = []
    current_rank = 0
    
    for s in stabilizers:
        row = to_binary([s])[0]
        test_rows = current_binary_rows + [row]
        new_rank = gaussian_elimination(test_rows)
        if new_rank > current_rank:
            independent_stabilizers.append(s)
            current_binary_rows.append(row)
            current_rank = new_rank
            
    print(f"Independent base stabilizers: {len(independent_stabilizers)} (Rank: {current_rank})")
    
    current_stabilizers = independent_stabilizers.copy()
    
    # Check commutativity of the base set first
    print("Checking commutativity of base set...")
    for i in range(len(current_stabilizers)):
        for j in range(i+1, len(current_stabilizers)):
            if not current_stabilizers[i].commutes(current_stabilizers[j]):
                print(f"Error: Base stabilizers {i} and {j} anticommute!")
                return

    # Try to fill up to n
    # We use a tableau to track independence? 
    # Actually, we can just keep adding to the list and check if valid.
    # But checking independence is hard without a tableau.
    # Tableau.from_stabilizers fails if not full rank? No, it works for n stabilizers.
    
    # Let's try to add one by one.
    
    for k in range(n):
        if len(current_stabilizers) == n:
            break
            
        # Candidate: Z on qubit k
        candidate = stim.PauliString(n)
        candidate[k] = 'Z'
        
        # Check commutativity with current set
        commutes = True
        for s in current_stabilizers:
            if not s.commutes(candidate):
                commutes = False
                break
        
        if commutes:
            # Check independence
            # We can try to build a Tableau from the current set + candidate + dummy to fill?
            # Or just assume independence? No, Z_k might be a product of others.
            
            # Efficient way: Gaussian elimination.
            # But let's just use try-except with Tableau.from_stabilizers ONLY when we reach n.
            # Wait, we can't do that until the end.
            
            # Stim doesn't have a direct "is_independent" check for partial sets.
            # But we can try to add it. If we can't reach n, we backtrack?
            # Greedy approach usually works for stabilizer completion with Z/X basis.
            
            # Let's verify independence by seeing if it's already in the group generated by current.
            # This is hard.
            
            # Alternative: Add it. If at the end we have < n, we failed.
            # But if we add a dependent one, we don't increase the group size.
            # Actually, if we add a dependent one that is NOT in the group (i.e. -1 phase), it's inconsistent.
            # If it is in the group (+1 phase), it's redundant.
            
            # Let's just collect candidates and then filter?
            current_stabilizers.append(candidate)
            
    print(f"After Z pass, we have {len(current_stabilizers)} stabilizers.")
    
    if len(current_stabilizers) < n:
        # Try X_k
        for k in range(n):
            if len(current_stabilizers) == n:
                break
            candidate = stim.PauliString(n)
            candidate[k] = 'X'
            commutes = True
            for s in current_stabilizers:
                if not s.commutes(candidate):
                    commutes = False
                    break
            if commutes:
                current_stabilizers.append(candidate)
                
    print(f"After X pass, we have {len(current_stabilizers)} stabilizers.")

    # Now we might have more than n because we added redundant ones.
    # Or fewer.
    
    # Actually, if we added redundant ones, Tableau.from_stabilizers will complain "The generators are not independent".
    # So we need to filter them.
    
    # How to filter for independence?
    # We can use `stim.Tableau.from_stabilizers` on subsets?
    # No, it expects exactly n.
    
    # We can assume the original 151 are independent.
    # Then we check each added one.
    # But how to check independence of 151 + 1?
    
    # We can rely on the fact that if we have n commuting independent stabilizers, they form a valid tableau.
    # If we have n commuting but dependent, `from_stabilizers` raises error.
    
    # So we have a list of candidates (original + added).
    # We want to find a subset of size n.
    # We know the first 151 are fixed.
    # We need to pick 20 from the added ones such that the total set is independent.
    
    base_stabilizers = stabilizers
    added_stabilizers = current_stabilizers[len(base_stabilizers):]
    
    print(f"Base: {len(base_stabilizers)}, Added candidates: {len(added_stabilizers)}")
    
    # Brute force or greedy search to find the right ones?
    # Or just try to construct tableau.
    
    # Let's use a simpler approach: 
    # Just fill the 20 missing slots with something that works.
    
    # If we have 151, we need 20.
    # Let's iterate through added candidates and try to build the tableau.
    # But checking independence is the key.
    
    # Maybe we can use `stim.TableauSimulator`?
    # Initialize a simulator.
    # Measure all base stabilizers. This projects the state.
    # Then measure candidate Z_k. If the result is deterministic, it's already stabilized (redundant).
    # If random, it's independent (and measuring it adds it to the stabilizer group).
    
    sim = stim.TableauSimulator()
    # We start in |00...0> which is stabilized by Z_0, ..., Z_{n-1}
    # This might conflict with our target state.
    # We want to find a state stabilized by 'base_stabilizers'.
    # We can measure them.
    
    # But if 'base_stabilizers' anticommute with Z basis (initial state), the outcome is random.
    # That's fine. We force the outcome to be +1?
    # Stim's `measure_expectation`?
    
    # Better: Start with a maximally mixed state? No, simulator is pure.
    # Start with |0>. Measure all base stabilizers.
    # If we measure P and get -1, we apply a correction? 
    # Or we just force the measurement result?
    # `sim.measure_kickback`?
    
    # Actually, we can use `sim.set_inverse_tableau`? No.
    
    # Let's do this:
    # 1. Start with |0...0> (Stabilizers Z0...Z170).
    # 2. For each base stabilizer S:
    #    Measure S. If random, it replaces one of the existing Z stabilizers.
    #    If deterministic +1, good.
    #    If deterministic -1, we have a problem? No, we just record it.
    #    Wait, we want to PREPARE a state that is +1 eigenstate.
    
    # If we measure S and get -1, we can flip it by applying an anticommuting operator.
    # But we want to construct the circuit.
    
    # The `Tableau.from_stabilizers` is the right way if we have n independent stabilizers.
    # So we need to find 20 that complete the set.
    
    # Let's use the simulator to find independent ones.
    # Reset simulator.
    sim.do(stim.Circuit(f"R 0 {n-1}")) # Reset to |0>
    
    # We want to replace the initial Z stabilizers with our Base stabilizers.
    # But we want to know which Z stabilizers remain or can be added!
    
    # Actually, if we measure the 151 base stabilizers on the initial |0> state:
    # They will commute with some Z's and anticommute with others.
    # After measuring 151 independent Paulis, we will have 151 stabilizers fixed (up to sign).
    # And 20 degrees of freedom remaining.
    # We can check which Z_k are still independent (i.e. measurement is random).
    # If measurement of Z_k is random, then Z_k is independent of the current set.
    # We can then "add" it to our set (by effectively measuring it).
    
    # So:
    # 1. Start with |0>.
    # 2. Measure all 151 base stabilizers. (Ignore outcomes for now, just updating the state).
    # 3. Iterate k=0..170. Measure Z_k.
    # 4. If result is random (sim.peek_bloch shows 0?), then Z_k is a new independent stabilizer.
    #    Add Z_k to our list of 171.
    # 5. Stop when we have 171.
    
    # Wait, `peek_bloch` is for single qubits.
    # `canonical_stabilizers` gives the current stabilizers.
    
    # Let's try this simulator approach to finding the completion.
    
    sim = stim.TableauSimulator()
    # Apply Identity to ensure size
    sim.do(stim.Circuit(f"I {n-1}"))
    
    final_stabilizers = base_stabilizers.copy()
    
    # We can't just "measure" in the simulator and get the stabilizer description easily without parsing canonical.
    # But we can use `sim.measure_observable(p)`? No.
    
    # Let's use `peek_z(k)`.
    # If we measure the base stabilizers, the state evolves.
    # BUT, we need to construct the full set of 171 PauliStrings to pass to `from_stabilizers`.
    
    # We can maintain a list of stabilizers.
    # We iterate through Z_k. Check if Z_k is independent of `final_stabilizers`.
    # How?
    # Use Gaussian elimination (internal to Stim?).
    # Stim doesn't expose it.
    
    # Let's just try to add them and check if `from_stabilizers` works for the subset?
    # No.
    
    # Let's go back to: 
    # We have 151.
    # Try adding Z_0. Check if {151} + Z_0 is independent.
    # How?
    # Construct a Tableau with 152 rows? Stim doesn't support that.
    
    # However, we can use `stim.Tableau.from_stabilizers` with padding?
    # No.
    
    # We can write our own Gaussian elimination check.
    # Convert PauliStrings to binary vectors (2n bits).
    # Stack them. Compute rank.
    # If rank increases, it's independent.
    
    def to_binary(paulis):
        # paulis is list of stim.PauliString
        # Returns matrix of bools
        if not paulis: return []
        num_qubits = len(paulis[0])
        rows = []
        for p in paulis:
            row = []
            # X part (X=1, Y=2 have X component)
            for k in range(num_qubits):
                # p[k] returns 0=I, 1=X, 2=Y, 3=Z
                val = p[k]
                row.append(val == 1 or val == 2)
            # Z part (Y=2, Z=3 have Z component)
            for k in range(num_qubits):
                val = p[k]
                row.append(val == 2 or val == 3)
            rows.append(row)
        return rows
        
    def gaussian_elimination(rows):
        # rows is list of list of bools
        # Returns rank
        # Standard Gaussian elimination over GF(2)
        if not rows: return 0
        num_cols = len(rows[0])
        mat = [r[:] for r in rows] # copy
        rank = 0
        pivot_row = 0
        
        for col in range(num_cols):
            if pivot_row >= len(mat): break
            
            # Find pivot
            pivot = -1
            for r in range(pivot_row, len(mat)):
                if mat[r][col]:
                    pivot = r
                    break
            
            if pivot != -1:
                # Swap
                mat[pivot_row], mat[pivot] = mat[pivot], mat[pivot_row]
                
                # Eliminate
                for r in range(len(mat)):
                    if r != pivot_row and mat[r][col]:
                        # XOR
                        for c in range(col, num_cols):
                            mat[r][c] = mat[r][c] ^ mat[pivot_row][c]
                
                rank += 1
                pivot_row += 1
                
        return rank

    # Convert base to binary
    print("Converting to binary...")
    # This might be slow for many calls. 
    # But we only do it incrementally.
    
    base_rows = to_binary(base_stabilizers)
    current_rank = gaussian_elimination(base_rows)
    print(f"Base rank: {current_rank}")
    
    if current_rank < len(base_stabilizers):
        print("Warning: Base stabilizers are not independent!")
        # We should prune dependent ones?
        # But let's proceed.
        
    candidates_added = []
    
    # Try Z_k
    for k in range(n):
        if len(base_stabilizers) + len(candidates_added) == n:
            break
            
        # Z_k binary
        # Z has X=0, Z=1
        row = [False]*n + [False]*n
        row[n+k] = True
        
        # Check if rank increases
        test_rows = base_rows + to_binary(candidates_added) + [row]
        # Optimization: only run GE on the new row against the basis?
        # Re-running full GE is fine for 171x342 matrix.
        
        new_rank = gaussian_elimination(test_rows)
        if new_rank > current_rank + len(candidates_added):
            candidates_added.append(stim.PauliString(n))
            candidates_added[-1][k] = 'Z'
            print(f"Added Z_{k}")
            
    # Try X_k if needed
    if len(base_stabilizers) + len(candidates_added) < n:
        for k in range(n):
            if len(base_stabilizers) + len(candidates_added) == n:
                break
            # X_k binary
            row = [False]*n + [False]*n
            row[k] = True
            
            test_rows = base_rows + to_binary(candidates_added) + [row]
            new_rank = gaussian_elimination(test_rows)
            if new_rank > current_rank + len(candidates_added):
                candidates_added.append(stim.PauliString(n))
                candidates_added[-1][k] = 'X'
                print(f"Added X_{k}")

    full_set = base_stabilizers + candidates_added
    print(f"Total stabilizers: {len(full_set)}")
    
    if len(full_set) == n:
        try:
            tableau = stim.Tableau.from_stabilizers(full_set)
            circuit = tableau.to_circuit(method="elimination")
            with open(output_file, "w") as f:
                f.write(str(circuit))
            print(f"Circuit written to {output_file}")
        except Exception as e:
            print(f"Error creating tableau: {e}")
    else:
        print("Failed to complete the set.")

if __name__ == "__main__":
    stabilizers_file = r"C:\Users\anpaz\Repos\quantum-ai\rq1\data\gemini-3-pro-preview\agent_files\stabilizers_171.txt"
    output_file = r"C:\Users\anpaz\Repos\quantum-ai\rq1\data\gemini-3-pro-preview\agent_files\circuit_171.stim"
    solve_stabilizers(stabilizers_file, output_file)
